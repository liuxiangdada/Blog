## 网络

1.计算机网络模型

计算机网络模型分为5层和7层，7层实际上是对应用层的细分，所以我讲一下五层模型，最底层是物理层，接着是数据链路层，然后是网络层，网络层有比较著名的IP协议，再网上是传输层，传输层有UDP协议和TCP协议，最后是应用层，应用层有FTP协议，SFTP协议，HTTP协议等等，从下网上把数据层层拆分包裹起来

数据的封装？

2.UDP和TCP的区别以及它们的应用

UDP是面向无连接的传输协议，它的特点是不需要通信双方确认身份，建立的连接也不是可靠的，可以随时中断，连接比较快速简单，适合对即时性要求高而对连接可靠性要求低的数据传输服务

TCp是面向连接的传输协议，它需要在通信前通过三次握手建立可靠的连接，才能进行通信，通信的过程中会提供一些算法机制来确保传输的稳定，比如说丢包重传、拥塞控制等等

据我所知，DNS域名解析是基于UDP的，而TCP是HTTP协议的基础

3.http和https的建立过程以及区别

http的通信简述为三次握手和四次挥手

三次握手阶段，开始客户端向服务器发起请求建立连接，同时客户端做一些准备工作，比如分配端口，服务器接收到请求后，也会做出请求的准备工作，然后通知客户端我已经准备好通信了，客户端收到响应后，会再次发出一个请求确认收到服务器的响应，这时已经可以发送数据了

为什么要客户端二次确认呢，这是因为服务器在收到握手请求后，会为客户端保留这个通信所需的资源到一个队列，如果超过一定时间客户端不响应的话，说明有可能是丢包了或者客户端不再需要握手，这时就会浪费服务器的资源，著名的ACK泛红攻击就是这个原理

四次挥手，当数据交换完成后，客户端发起结束通信的请求，告诉服务器我需要关闭通道比如说端口之类的资源，服务器接收到后就会回应这个请求，告知客户端我已经知道需要关闭了，同时继续发送未发完的数据，等到数据发送完毕后，服务器会再发送一个FIN报文，表示我也要结束这个通信了，客户端在收到后，就会发送一个确认报文同意服务器的结束请求，在这个期间，客户端在收到服务器的结束请求并发送确认后，还会保持连接 2 * MSL（最长报文的寿命）时间长，这个主要是考虑到客户端的确认报文丢失的情况，所以客户端的结束连接时间要比服务器要晚一点

https就是加装了SSL协议的http请求，SSL被称为安全套接字层，客户端在请求时会生成随机数a，服务器提供证书并生成随机数b，然后从证书中拿到公钥，用它加密生成随机数c发送给服务器，这样就得到了三个随机数和哈希算法以及压缩算法等信息，接着双方就可以各自组合出最终通信的会话密钥并用这个密钥进行通信

4.http请求的请求头和响应头

http的请求行包含请求的动作，使用的协议以及版本号，请求的地址

请求头还包括报文头，定义一些请求的控制数据比如说常见的，content-type指定请求的文本类型，接着还有报文体，是具体的请求数据

http的响应行包括响应的协议及版本，响应的状态吗和状态描述

响应包括响应头和响应体，响应头和请求报文头类似，用于服务器控制响应的一些数据，其次是数据主体

5.http请求动作有哪些，options请求的作用

http的请求动作有GET、POST、PUT、HEAD、OPTIONS

GET用于获取资源，POST用于客户端向服务器发送数据，HEAD用于请求协商头部信息，PUT用于指定服务器把资源放到何处，OPTIONS用于请求服务器的相关运行信息

6.http2.0的优势

http2.0的优势简要来说就是二进制流包括在帧这个数据体进行传输，以二进制流为基础实现了多路复用，使得我们不必等待前一个请求响应完成才处理下一个请求，可以同时发送多个响应的数据，然后还有的新特性就是压缩请求头，具体就是在初次请求后，双方都会建立一张表记录请求头部信息，然后接着就可以使用简单的索引代表具体的信息以此压缩头部的体积，然后还有一个新特性是服务器推送，这个是靠帧来实现的，通过表示帧的类型让客户端知道这是一个推送请求

http2.0因为解决了对头堵塞，使得压缩请求数量变得不那么重要了

7.几种跨域方式

JSONP，利用script标签src属性可跨域请求的漏洞进行与不同源的服务器之间进行通信，原理是通过客户端发送一个定义好的处理数据的回调函数名，服务器组装这个函数并传入参数使之形成一个函数调用，这样客户端在请求脚本完成后就会执行内部组装的执行代码，执行回调就拿到了参数中数据

CORS，跨域资源共享，现代浏览器默认都支持，只要服务器做一些简单的配置就能实现跨域请求，服务器会指定能够跨域的源，如果接受到请求就会判断是否在接受的范围内，如果是就同意请求，发送响应数据

什么是简单请求，什么是非简单请求，什么是预检请求？

简单请求的动作只能是GET、POST、HEAD之一，然后对一些请求头有限制，比如说只能设置一些接收的类型，接收的语言等字段，然后请求的内容只能是text/plain等简单的文本类型或者表单提交

其他都是非简单请求

预检请求用于避免跨域请求污染用户数据，主要使用options请求动词，处理跨域的一下相关确认，之后和简单请求一样正常通信

nginx反向代理，这个也只需要配置nginx把请求到同源的请求转发到其他域名的服务器，处理后在转发回客户端

postMessage，一方通过这个函数发送数据，另一方通过监听mesage事件来接收数据

window.name这个用于不同iframe标签可以共享name变量

指定iframe标签的domain属性为同值就可以让子域的iframe标签共享主域中的属性，通过window.parent拿到数据

8.XSS和CSRF

XSS名为跨站脚本攻击，通过在用户可输入的位置输入一些恶意代码来植入到网页中或者数据库中，达到攻击者攻击网站或者利用网站或者其他用户信息的行为，这个漏铜的主要就是输入没有经过合法性教研就被使用，导致恶意代码被执行

CSRF为名跨站请求伪造，通过在用户已经获得登录凭证的网站点击一些超链接等进入攻击者的网页，然后在不知情的情况下，在攻击者的网页发起了对目标网页的请求，以达到获取用户信息或者财产的目的

如何预防CSRF呢？

CSRF主要利用了Cookie会在请求时被携带的特性

首先我们可以在请求头中设置一个攻击者无法拿到的token，只有通信双方能够加密解密确认，这样攻击者发起的请求就不会被处理

也可以针对关键操作使用验证码等手段确保是本人操作

还有就是判断请求的Referer，这个信息一般是无法伪造的，代表请求的来源的地址信息

还可以禁止在不同源携带cookie进行请求，通过设置cookie的samessite属性为严格模式


## 项目

1.浏览器缓存，服务端渲染

浏览器会根据响应对请求数据做出不同的处理，一般来说，针对一个可被缓存的数据，浏览器会把它缓存到内存或硬盘中，并设置过期时间（来自响应头），在过期时间内都不再向服务器发起请求而是直接使用缓存数据，本地缓存失效后，会进入协商缓存阶段，用上次请求返回的（last-modified和etag）去询问服务器缓存是否更新，如果失效则需要重新请求数据，否则返回304提示客户端继续使用缓存并更新过期时间

服务端渲染对应于客户端渲染，一般现在的客户端渲染都是需要加载完JS后根据JS动态生成DOM节点，这样不仅增加了渲染页面的时间，也不利于搜索爬虫爬取数据，就是不利于SEO，所以使用服务端渲染，服务器在本地把html拼接好，直接发回给客户端，这样客户端就不需要动态计算，而是直接交给渲染线程渲染出页面

2.首页白屏优化

首页白屏优化可以从几个角度来做，拿小程序的首屏优化来说，我们从代码、请求、图片、渲染等几个角度来说

代码方面我们可以进行拆包，把首页渲染之外的其他页面或其他组件放到其他包中，这样只有在真正使用的使用才会去下载并加载

还可以减少代码包的体积，通过优化合并冗余代码，打包时使用树摇策略不打包未使用模块，压缩代码等加快下载代码包的速度就可以快一步进入渲染流程

请求方面我们可以使用本地缓存，第一次请求时缓存到本地并，先使用本地缓存渲染，然后真正的请求数据，根据请求数据更新页面

在小程序侧还提供了预加载的能力，通过配置可以做到提前到下载代码包时请求数据， 这样就可以存到本地直接使用本地数据，加快渲染，类似的还有周期性拉取

图片方面，小程序尽量避免使用本地图片而是使用网络图片，使用的图片最好是小图，尤其是首页尽量不要设置太多的大图区域，因为大图加载的速度很慢且会卡顿，如果非要使用本地图片可以使用精灵图并压缩，这样最后转成base64后可以减少代码包的体积

渲染方面主要是图片懒加载和列表滚动渲染，初始只渲染首屏数据，首屏之外的数据只有在滚动到指定位置时才开始渲染

用户角度可以在请求数据时使用骨架屏代替白屏减少用户的等待焦虑度

3.性能优化实践

原来做过一些性能优化，包括压缩合并JS/CSS、图标使用字体图标、多个小图整合成精灵图等减少http请求数量，减少http请求数据大小的优化，此外还做过把一些静态资源比如图片、JS/CSS放到其他的域名以避免浏览器同一域名的请求数量的限制的优化

代码方面的优化做过，整合代码，删除冗余代码，相同功能使用组件实现复用，打包时引入树摇减少代码体积的优化

渲染方面把CSS放到头部加快页面渲染，JS脚本放到body尾部避免阻塞，渲染时避免频繁操作DOM，比如一个文本在脚本中多次改动，可以创建一个节点先不插入DOM中，对这个节点处理完毕后再插入DOM，对于数目较多的节点可以不循环插入，而是创建一个documentFragment切片，先把节点以一定数量放置到切片中分批渲染，减少DOM操作

CSS方面避免使用标签选择器，避免使用通配符

用户体验方面做过loading页，在一些耗时很长的异步操作增加loading页缓解用户焦虑，还有骨架屏等等，还做过基于接口的错误反馈机制页面，告知用户出现错误的点

4.项目中的几个关键点

使用UNI-APP开发使用条件编译适配H5和小程序

使用原生重新开发，自己构建工作流，自己编写基于Vue语法的包装函数，自己封装了路由的使用API，同时编写了很多基础组件包括，toast、modal、pic、navbar、swiper等等

业务中遇到两个比较大的点值得说，一个是请求接口自动登录，利用队列实现并发接口的问题；另一个是实现了sku选择算法，基于全排列和无向图邻接矩阵的思路，首先我们获取到有库存的sku，然后把所有值描述成点存在一个矩阵中，有库存的各个规格之间用边连接表示有库存连通，然后根据用户输入从矩阵中找这个点的邻接点，然后合并多列，判断每个点的邻接点数是否大于输入sku的数量确定是否存在连通关系，这个算法一开始运行的很好，直到有一天发现了一个BUG，问题出在无向图可能会形成环，所以我在最后一步判断时放弃使用矩阵而是回到全排列判断，修复后运行良好

5.CDN的实现原理

CDN又叫做内容分发网络，基本原理是把一些静态资源放到全国的服务器中，如果主服务器在北京，然后是深圳的用户请求，就会在DNS解析时根据IP的响应速度返回最快的那个IP，这样就找到离你最近的CDN服务器了，CDN的优势就是快，对于不经常变更的静态资源，它能够极大的加快响应时间

CDN实现查找的原理是基于一个IP地址库和调度系统，当你发起请求时，会向DNS域名解析服务器发起域名解析请求，在域名服务器中存放着一个IP数据库，它会根据以往的请求响应时间来选择一个最快的返回其IP给用户

6.响应式布局

PC端的响应式布局可以使用百分比布局或者VW和VH，新的flex的布局也支持响应式

此外，如果要适配不同设备，可以考虑媒体查询，根据不同设备的分辨率单独配置

移动端的响应式布局主要靠rem，rem就是以根节点的字体大小为基准，设置其他元素的尺寸和位置。根节点的字体大小会根据设备分辨率进行换算，比如我们以320宽的设备机型设计，计算出其他设备相对于320的比例，然后等比缩放字体

在小程序侧使用的是rpx，类似于rem，也能够实现自动缩放

7.兼容性处理

兼容性处理分为CSS兼容、JS兼容、浏览器兼容

CSS兼容可以通过浏览器前缀或者CSShack来实现

JS兼容需要判断浏览器代理，然后根据不同浏览器调用不同的API，这是因为不同的浏览器对于标准有不同的实现

浏览器兼容主要是兼容IE，在使用新的API前先判断

## 工具

1.webpack的生命周期及相关配置

webpack有编译阶段，该阶段接收入口文件并根据文件中的引用递归找到引用文件，然后就可以解析成浏览器能识别的模块导入代码，在解析期间会碰到非JS文件，这时就可以调用各个loader进行解析，解析完成后就构建出了一张依赖表，我们根据chunk配置进行打包并输出到output中，在webpack的整个流程中会在特定时机广播事件以便插件调用

webpack的配置有Entry、Output、loader、plugins

2.单元测试，Jest

我做过基于Vue的单元测试，使用的是官方的测试库，配置好后，就可以对自己编写的组件编写测试，主要是导入组件或者方法，然后模拟输入，断言输出

3.babel的原理

babel是一个用于转化JS的工具，它能够让我们使用最新的JS标准开发，然后编译成浏览器能执行的JS版本代码，

babel的工作原理是先把新代码转化成AST节点，然后修改AST节点，最后转换回对应版本的代码，babel本身只实现了解析和生成两个功能，中间的转化功能交给插件去实现，我们可以实现基于不同版本JS的转换插件，babel官方也内置了一些转化插件方便开箱即用，babel实现解析调用了babylon库，它使得babel能够尽可能识别最新的语法

## Node

1.Node的事件循环过程

Node端事件循环分成几个阶段，首先是定时器回调timer阶段，接着是3个内部阶段（IO callback阶段，执行一些系统错误，网络错误，接着是idel阶段和prepare阶段，仅内部使用），跳过，然后是IO请求回调poll阶段，接着是setImmediately回调check阶段，最后是close阶段，每个阶段都会检查其队列中有无回调，有的话执行回调，执行完队列中的回调后，执行微任务队列，注意process.nextTick中的回调在微任务队列之前执行

2.Node开发koa的中间件原理

Koa中间件允许我们执行多个异步操作并等待其他异步操作完成后再接着执行当前中间件的剩余代码，原理是use时把中间件放入一个执行数组中，等到listen调用时，内部调用callback函数，该函数会返回一个执行compose取出第一个中间件并执行的Promise，等到执行到await next时就会内部调用dispatch(i++)执行下一个中间件，等到下一个中间件执行结果出来后resolved，第一个中间件继续执行剩余的代码

3.几种数据库的区别和不同，事务是什么

分为关系型数据库和非关系型数据库，关系型数据库有mysql，非关系型数据库有mongodb，还有内存型数据库比如redis

区别是读取速度redis > mongodb > mysql，mysql比较成熟，支持sql语法，但在处理海量数据时性能下降；而mongodb基于内存，会把热数据放到内存中，所以性能较高

mysql支持事务

事务是在执行一组sql语句时，如果其中任何一条语句出错，都会撤销所有的执行结果，它确保了执行的一致性

## DOM

1.加载大数量节点的优化

定义一个documentFragment切片完成节点的批量插入和更新操作，然后再把该切片插入到DOM中，可以控制每次批量插入的数量然后在页面渲染前插入，使用requestAnimationFrame

window.requestAnimationFrame接收一个回调，告诉浏览器在下次重绘时执行回调，所以使用方式就是
```
function appendItems () {


  dotAppend ()
}

dotAppend () {
  window.requestAnimationFrame(appendItems)
}

dotAppend()
```

2.鼠标拖拽事件的实现

鼠标拖拽事件通过三个事件实现，分别是mousedown，mousemove，mouseup，核心是要确定左边界0和右边界盒子的宽减去自身的宽，计算位移距离的方式是计算鼠标与移动元素的相对距离，然后保持这个相对距离即可

3.文件上传

文件上传通过监听input[file]的change事件，通过files属性拿到选中的文件，然后使用FileReader对象读取readAsArrayBuffer这个文件（注意截取文件的大小），最后调用onload方法将文件发回服务器，文件需要被包裹在formData中以new Blob([file.result])转为二进制传输

通过监听xhr.onreadstatechange回调，当readyStatus === 4 && status === 200时执行成功回调继续读取下一切片的文件，否则重新读取上一次的切片

## CSS

1.定位

定位包括static、relative、absolute、fixed、sticky

static为默认定位，在文本流中

relative相对于自身定位

absolute相对于第一个定位的父元素定位，否则就是body或者table

fixed相对于浏览器视窗定位

sticky在平时等于absolute，吸顶时相当于fixed

2.层级如何决定的

首先html页面由不同的层叠上下文决定，只有在同一上下文中的元素比较才有意义，可以形成层叠上下文的方法有很多，只要形成了层叠上下文，我们就按照这样的顺序来

背景边框->负index->正常文档流的块级元素->浮动元素->文档流中的行内元素->z-index为0的定位元素->z-index大于0的定位元素

3.动画实现方式

通过transition实现过渡动画

通过@keyframe实现动画

移动转换使用transform属性、rotate

也可以在JS中使用requestAnimationFrame方法来实现动画，效果比setTimeout要好

4.BFC

BFC又称块级格式化上下文，形成块级格式化上下文的元素独立于其他元素，内部样式不影响外部，外部也无法影响内部的样式

使用overflow不等于visible，float不等于none，position不等于static和relative等方法可以实现

5.垂直水平居中

padding+margin

position+margin

position+transform

flex

margin: auto

text-align: center + vertical-align: middle

6.flex布局

justify-content控制主轴（行）的布局行为，居中（center），左边（flex-start），间距（space-around外侧有留白），间距（space-between，外侧无留白）

align-items控制交叉轴（列）的布局行为，值和上面类似，baseline（基于文本下方进行布局），stretch（充满整个交叉轴）

align-content控制多根轴线的对齐方式和justify-content类似

项目上可以设置order、align-self、flex-grow、flex-shrink、flex-basis


## 算法

1.动态规划（正则匹配）

2.堆排序

堆排序首先要构建大根堆或者小根堆，一般是升序排列，所以构建大根堆，我们从第一个非叶子节点开始比较，一直到根节点，从右到左，从下到上，构建完堆后，就交换根节点和堆尾的元素，然后在重新调整n-1长度的堆

调整堆的方法是先记录堆顶元素，然后比较其左右子节点(2*i + 1, 2*i + 2)，如果右子节点大，则再和堆顶元素比较，如果右子节点大，则把堆顶的值修改为右子节点的值，同时保存右子节点的下标，否则不需要调整，跳出循环

3.JS中堆栈的区别

JS中栈为系统自动分配的空间，大小由分配时确定下来，存放基本数据类型，会被系统自动回收，优点是读取写入快，缺点是大小与生存周期确定，不够灵活

堆为动态分配的内存，大小不定不会自动释放，存放引用类型，优点是堆中的对象不会因为方法的结束而结束，因为可能还被其他方法中的变量引用

4.数据结构中堆栈的区别

栈是一种后进先出的数据结构，而堆是一种完全二叉树

5.二叉树的遍历、搜索，用二叉树实现序列化

6.防抖节流的区别以及实现

7.合并两个有序数组到第一个数组，假设第一个数组空间足够大

定义三个指针，a、b、c分别表示数组1的末尾和数组2的末尾和新数组的末尾，比较1、2两个数组的末尾值，取大值放入新的末尾，同时取值的数组指针向前移动，新数组的末尾指针向前移动，最后会出现两种情况，1数组仍然有元素，这时我们不用再处理，因为剩余元素本来就在有序数组中，如果数组2还有元素，则需要把数组二的元素依次放入新数组中

