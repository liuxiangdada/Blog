# JS基础知识笔记

## 类型、值和变量

1. JavaScript的类型可分为可变类型和不可变类型，不可变类型如数字、布尔值、null和undefined；可变类型如数组、对象，他们可以修改属性值或者数组元素的值。要注意的是字符串虽然可以看成是字符组成的数组，但它是不可变的，JavaScript并未提供修改已知字符串的方法
2. JavaScript里数字的类型只有Number类型，也就是64位的浮点数，其对整数的表示等同于双精度浮点数对整数的表示
     - 双精度浮点数由1位符号、11位指数、52位尾数构成，计算机储存数字是按照科学计数法来存的，我们知道所有的十位数都可以表示为`1.xxx * 10 ^ n`，但是计算机并不认识十进制，我们只能把数字转化成二进制的科学计数法`1.xxx * 2 ^ n`
     - 十进制浮点数转为二进制时整数部分采用`除2取余，逆序排列`，小数部分采用`乘2取整，顺序排列`，举个例子，8.25转成二进制为1000.01，用科学计数法表示为`1.0001 * 2 ^ 3`，由于指数位是采用移位储存的，指数位都在原数值的基础上加`2 ^ n - 1`进行储存，单精度下指数位为8位，所以指数位的储存值为130，尾数位由于首位都为1，可省略不存，即单精度下储存为`0 10000010 0001...0`
     - 现在我们根据这个来计算最大整数，我们推测出当二进制科学计数法为`1.111...111 * 2 ^ 52`时达到最大，因为再加1则尾数总位数变为53位，超出52位尾数的表示范围了，多出的部分被截断，意思就是我们无法区分`2 ^ 53`和`2 ^ 53 + 1`，也就是不安全了，所以安全整数的范围为`-2 ^ 53 - 2 ^ 53`（不包含边界）
3. 浮点数可以使用指数计数法，具体语法是将10进制科学计数法的10用`E|e`表示，后面跟指数值，如`1.25 * 10 ^ 6`可以表示为`1.25e6` 
4. `Math.log(10)`表示为以自然对数为底10的对数；`Math.log(100)/Math.LN10`表示以10为底100的对数，这是因为Math.LN10为10的自然对数，根据换底公式可得
5. Javascript中的非数字值由一些异常计算得到，比如`0 / 0`，`-1 / Infinity`，`parseInt('abc')`，NaN与任何数都不相等，包括自身，所以判断一个数是否为NaN，可以用`isNaN`方法
6. Javascript采用IEEE-754浮点数表示法，这种表示法无法精确的表示0.1这样简单的浮点数，所以我们会发现`0.1 + 0.2 !== 0.3`这样的现象
7. 关于JS的Date对象，有几点要注意
     - getYear方法获取的是距今的年份差
     - getMonth方法获取的月份数是从0开始数起的
     - getDay方法获取的是星期，并且0表示星期日
8. null是Javascript中的一个关键字，表示一个特殊值，使用typeof求其类型得到object，这表示我们可以将其看成一个特殊对象，意为非对象，通常用来表示数字、字符串和对象是无值的
9. undefined是JavaScript中定义的第二个表示值的空缺的关键字，含义是未定义，可以用来表示一个被定义但没有被初始化、没有返回值的函数返回undefined、引用未提供函数实参的形参的值得到undefined
10. null和undefined的区别：undefined表示系统级的、出乎意料的或者类似错误的值的空缺，而null表示程序级的、正常的或在意料之中的值的空缺
11. 我们知道，像数字、字符串、布尔值这种基本数据类型是原始值的一种，但为什么我们可以使用方法呢，比如说`'abc'.charAt(0)`，原因是JavaScript在发现引用了字符串的属性时，会自动调用其包装对象方法将其转化成对象，并调用这个临时对象的方法，结束后销毁，这也是为什么我们调用undefined或者null的属性或方法时报错的原因，因为它们没有包装对象方法
12. 试图将`null`和`undefined`转化为对象都会引发错误，但是调用`Object()`方法不会，只是简单的返回一个空对象
13. 对比`Number()`、`parseInt()`和`parseFloat()`
    - Number，只支持10进制转化，不接收第二个参数，不能出现非法字符
    - parseInt，接收第二个参数指定转化的基数，比如说指定5就逢5进一，会跳过任意数量的前导空格，遇到非法字符停止，首位不可出现非法字符，遇到小数会四舍五入
    - parseFloat，和parseInt类似，转化成浮点数
14. 对象转化为原始值的情况
    - 转化为布尔值，都为true
    - 对象转字符串的步骤：首先调用toString方法，并返回原始值结果，如果没有toString方法或者转化后不是原始值，调用valueOf方法返回原始值结果，如果还是无法得到原始值则报错
    - 对象转数字的步骤与转字符串正好相反
    - 对象默认的toString方法表现比较特殊，它并非返回对象的JSON串格式，而是返回格式如`[object 具体对象类型]`，其他对象如数组、日期、正则、函数继承且重写了该方法
    - 数组转数字先调用valueOf方法，返回数组本身，非原始值，继而调用toString方法返回字符串，再将字符串转化为数字
15. 一个变量的作用域是程序源代码中定义这个变量的区域，全局变量拥有全局作用域，在函数内声明的变量只在函数内有定义，是局部变量，函数参数也是局部变量
16. 块级作用域是指在花括号内的代码具有独立的作用域，变量在该区域外不可见。区别于其他语言的块级作用域，JS采用函数作用域，函数内定义的变量在声明它的函数体和这个函数体嵌套的任意函数体内都有定义，全局变量可以看成整个JS代码运行在一个全局函数内
17. JS的变量声明会在预编译阶段提到函数体的顶部，这在代码运行之前就已经发生，这意味着我们可以在一个变量声明之前就使用该变量
18. 变量的作用域链可以看成一个对象列表，当需要查找变量x的值时，首先在链中的第一个对象开始找，找到直接使用，否则继续查找链上的下一个对象，直到找不到抛出TypeError错误为止，当定义一个函数时，实际上保存了一个作用域链，当调用该函数时，会创建一个新对象来保存该函数的局部变量，并把这个对象放入保存的作用域链中，这样全局有两个对象；处理嵌套函数体的情况时，每次调用外层函数都会重新定义内层函数，重新创建内层函数的作用域链