### 内存分配

一句话概括，基本数据类型使用栈内存（闭包变量除外）；引用数据类型值在堆内存，指针变量在栈内存

以下数据类型存放在栈内存中

- boolean
- string
- number
- undefined
- null
- symbol
- bigint

所有对象数据类型都存放在堆内存中

<font color="red">对于闭包变量，如果仍然存放于栈中，在函数调用完成后就会被回收掉，显然是不符合实际情况的，所以闭包中的变量单独存放在堆内存中</font>

### 赋值内存分配

对于原始数据类型，赋值操作是直接新开一块内存，完整的复制变量值；而对于引用数据类型，由于其栈内存中保存的只是引用指针，对其赋值只会复制一份指针，其存放在堆内存中值是不会复制的，这导致了下面的结果

```
  let a = {foo: 1, bar: 2};
  let b = a;
  b.foo = 3;
  console.log(a); // {foo: 3, bar: 2}
```

### 内存回收

V8 引擎实现了垃圾回收算法，所以一般情况，前端程序员无需关注内存的使用释放情况，新建一个变量，引擎会自动开辟一块内存存放值，调用结束后会自动回收该块内存空间

我们来详细了解一下 V8 的垃圾回收机制的大致工作原理

首先 V8 对内存进行分代，新生代用于存放临时、短期变量，是临时分配的内存；老生代存放一些长期保存的变量，是常驻内存

#### 新生代

新生代内存的内存限制在 64 位下为 32MB，32 位为 16MB，虽然很小，但由于其内部存放的都是存活时间短的变量，因此可以设的足够小，不容易产生内存负担

新生代内存被一分为二，分别为 From 区间和 To 区间，From 区间为正在使用的内存；To 区间为闲置空间，执行垃圾回收时，检查其中的变量是否存活，存活则顺序复制到 To 区间，对调两者的角色，如此循环

新生代的垃圾回收使用了 Scavenge 算法，其解决了内存碎片问题，但是使得可使用的内存减少了整整一半

#### 老生代

- 新生代中的变量如果经历过多次回收后仍然存活，则会晋升到老生代内存中
- 如果 To 区间内存占用大于 25%也会触发某些变量的晋升

老生代的垃圾回收原来为引用计数，但是这种方式会导致很多内存泄露问题，已被浏览器抛弃，现代浏览器大部分都使用标记清除的方式，主要分为标记阶段和清除阶段，首先对所有对象打上标记，接着遍历堆中所有对象，对位于代码环境中的变量以及被强引用的变量取消标记，随后回收标记对象

标记清除方式回收后也需要解决内存碎片问题，V8 的解决方式比较粗暴，是压缩后直接全部都移动到一端，这个过程让整个垃圾回收十分耗时，实际上垃圾回收的主要耗时都是在移动这些对象上

由于 JS 的单线程特性，应用会被垃圾回收所阻塞，所以引入了增量标记的方式，即将一口气完成的标记任务分为很多小的部分完成，每做完一个小的部分就"歇"一下，让 js 应用逻辑执行一会儿，然后再执行下面的部分，如此循环，直到标记阶段完成才进入内存碎片的整理上面来

2018年后取得了技术突破，使得可以允许在标记存活对象的同时执行JS代码，被称为并发标记

