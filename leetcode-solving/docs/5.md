## 题目

给定一个字符串，找出其中最长的回文子串，假设给定字符串的长度小于1000

## 思路

我们对题目分析，关键词最长、回文、子串，也就是说我们最终的结果必须满足这三个必要条件

拆分问题，假设我们要求的字符串s的长度为n，如果我们能够求出掐头去尾长度为n - 2的子串的最长回文子串，再判断头尾是否相等就能得出最终结果

这是符合动态规划思想的，最终问题n长度的最优解可由子问题n-2长度的最优解递推而来，且子问题的结果对后面无影响，即不论n-2长度的最优解是如何，都不影响后面n长度的最优解求解过程，也就是无后效性

我们假设dp[i][j]表示以i开始以j结束的子串是否是回文子串，可推导出如下状态转移方程：

`dp[i][j] = s[i] + dp[i + 1][j - 1] + s[j]`

实际情况还需要考虑边界处理，简单带入几个例子推导，如果s的长度为0，应返回""，如果长度为1，则代表`dp[0][0] = true`，转化为具体代码可表示为：

`s[i] === s[j] && (dp[i][j] = j - i <= 2 || dp[i + 1][j - 1])`

又因为我们需要知道i+1的情况下dp的值，所以对i的遍历要从末尾开始

代码实现如下：

```
var longestPalindrome = function (s) {
  let n = s.length;
  if (n < 2) return s;

  let dp = Array.from({ length: n }, () => Array(n).fill(0));
  let res = "";

  for (let i = n - 1; i >= 0; i--) {
    for (let j = i; j < n; j++) {
      // 如果首位相等
      if (s[i] === s[j]) dp[i][j] = j - i <= 2 || dp[i + 1][j - 1];
      if (dp[i][j] && j - i + 1 > res.length) {
        res = s.substring(i, j + 1);
      }
    }
  }
  return res;
};
```
