# 软件工程

## 初识软件工程

1.软件 = 程序 + 数据 + 文档（实际包含某个领域的知识）

2.软件的本质特征
```
复杂性、一致性、可变性和不可见性等固有的内在特性
```

3.软件工程：致力于探索软件开发问题的解决之道

4.软件工程的发展
```
史前阶段（没有方法和设计） -> 瀑布过程模型 -> 质量标准体系（面向对象开发、过程改进） -> 敏捷开发
```

5.软件工程的基本概念：将工程化（系统性的、规范化的、可定量的）的方法运用到软件开发、运行、维护中
  - 三大要素：过程、方法、工具
  - 基本策略：软件复用、分而治之、逐步演进、优化折中

6.wasserman规范
  - 抽象：降低复杂性，只关注问题涉及到的部分
  - 软件建模方法：帮助工程师理解和刻画系统的分析和设计结果，便于沟通交流
  - 用户界面原型化：克服需求难以确定的问题
  - 软件体系结构：提升软件质量
  - 软件过程、软件复用、度量、工具与集成环境

7.温伯格定义的软件质量：质量就是软件产品对于某个（或某些）人的价值，一个软件既要是正确的，也要运行正确

8.ISO9126质量模型：功能性、可靠性、易用性、效率/性能、可维护性、可移植性

9.实现软件质量：高质量的设计 + 规范的编码 + 有效的测试

## 编写高质量代码

软件编码规范：是与特定语言相关的描写如何编写代码的规则集合
规范包含：模板、注释、命名、语句等

良好的编程实践
  看：阅读优秀的代码，学习别人的代码
  问：用专业规范的格式提出问题
  练：亲自动手编写代码

模块化程序设计：讲一个大的程序按功能分拆成一系列小模块
  基于易变和稳定
  基于单一职责划分：只有一个引起变化的原因

面向抽象编程

## 单元测试

## 软件开发过程

## 团队开发管理

开发团队组织模式
  1. 民主式结构
  2. 主程序员式结构
  3. 矩阵式结构

Brooks法则：向一个进度延迟的软件项目中增加人员可能会使其进度更加推迟

项目会议
  1. 项目启动会议
  2. 项目计划会议
  3. 项目阶段进展会议
  4. 项目技术评审会议
  5. 项目组内部会议

软件项目计划
  1. 开发问题描述： 问题背景，功能需求、非功能需求、其他需求
  2. 定义顶层设计
  3. 定义工作分解结构
  4. 建立初始时间表

软件项目估算：对结果进行估计，而不是活动

常用估算方法
  1. 专家估算
  2. 参数估算
      - 功能点方法
      - COCOMO公式： PM = A(SIZE)^B PM为人/月，A为工作量调整因子，B为规模调整因子，SIZE可以是功能点数/千行代码数
      - 用例点
      - 机器学习

## 敏捷开发和配置管理

### 敏捷开发

scrum框架：由若干个比较短的迭代周期(sprint)组成
  1. sprint类似于原来的瀑布模型，一旦确定将保持不变
  2. scrum团队角色：产品负责人、scrum主管(团队leader)、团队（5-9人）
  3. scrum制品：产品订单、迭代订单、可工作软件、燃尽图(以剩余工作量为Y轴，时间为X轴)
  4. scrum活动：迭代计划会议、每日站立会议、迭代评审会议、迭代回顾会议

用户故事：以用户的视角来描述需求
特征：独立性、可协商、有价值、可估算、短小的、可测试

### 配置管理

定义：软件配置管理是一种标识、组织和控制修改的技术，它作用于整个软件的生命周期，其目的是使错误达到最小并有效地提高生产率

软件配置项：是为了配置管理而作为单独实体处理的一个工作产品或软件

版本：是在明确定义的时间点上某个配置项的状态

基线：是软件配置项的一个稳定版本，是进一步开发的基础，只有通过正式的变更控制过程才能改变


版本控制
  1. 独占工作模式：A、B两个人修改同一个文件，如果A先修改，则代码库被锁定，等到A修改完合并到代码库后B才能修改
  2. 并行工作模式：A、B两个人修改同一个文件，如果A先修改，在A先合并代码情况下，如果B也合入代码，则代码库提示B本地的版本outdate，需要与最新版本比较再发布合并修改后的版本

## 需求获取

定义：需求是对外可见的系统特征

IEEE制定的定义：需求，是人们要解决的某个问题或达到某种目的的需要。是系统或其组成部分为满足某种书面规定（合同、标准、规范等）所要具备的能力。需求将作为系统开发、测试、验收、提交的正式文档依据

Herbert Simon的定义：每一个人造物都是一个内部环境与外部环境的接口。这里内部环境指人造物本身的设计组成。外部环境指人造物的周遭及其作用环境。对这个接口的描述即是需求


需求的内容
  1. 为什么要设计系统
  2. 系统由谁使用
  3. 系统要做什么
  4. 系统涉及哪些信息
  5. 对解决方案有何额外限制
  6. 如何使用该系统
  7. 质量需达到何种程度

需求的分类：对需求的划分是存在重叠的
  - 按产品需求细分为：功能需求、非功能性需求
  - 按抽象层次详细程度细分为：业务需求、系统需求、用户需求、软件设计规约

需求工程活动
  - 需求抽取
  - 需求分析
  - 需求规约
  - 需求管理
  - 需求验证

需求抽取的技术
  1. 面谈
  2. 问卷调查：多人在不同地点在方便时间围绕某个主题给出自己的见解
  3. 群体诱导技术
  4. 参与调查法
  5. 头脑风暴
  6. 需求研讨会
  7. 角色扮演
  8. 原型、仿真
  9. 建模分析
  10. 亲身实践
	
获取需求时的注意事项：善于倾听，确定对某一术语的含义理解一致

撰写需求文档
  - 针对小型项目：采用描述语言有条理的记录需求即可
  - 针对大中型项目：采用用例建模或者需求数据库来生成需求规格说明是必要的
  - 撰写的原则：简洁、可测试、使用约定术语、一次只专注一项需求

IEEE的需求规格文档模板大纲
  1. 介绍
  2. 术语表
  3. 用户需求规格说明
  4. 系统结构
  5. 系统需求规格说明
  6. 系统模型
  7. 系统的演化
  8. 附录
  9. 索引
   
## 用例建模

目的：描述系统的功能性需求

优势：
 1. 关联干系人需要以及软件需求
 2. 确认与系统交互的人或对象
 3. 定义系统边界
 4. 捕捉和传达系统的理想行为

表示方法：文本描述、用例图

用例图的主要元素
  1. 参与者：与系统交互的人或对象
  2. 用例：系统为参与者提供的有价值的功能
  3. 关联：用例图中用例与参与者之间的交互关系
  4. 箭头：关联要注意箭头的使用，一般由交互的发起方指向接收方

用例建模过程
  1. 寻找参与者：识别真正与系统交互的人或对象
  2. 寻找用例：假设参与者与系统进行交互
  3. 编写用例：划分用例事件重要等级，按重要等级详细描述事件流程

用例规约的描述过程
  1. 用例名称
  2. 参与者
  3. 前置条件
  4. 主事件流描述
  5. 异常场景描述
  6. 后置条件
  7. 注释
  8. 限制

## 面向对象分析与设计

面向对象分析起源
  1. 将面向对象程序设计中的概念上推到分析和设计阶段
  2. 将数据库语义建模概念，如实体-关系、泛化、聚合、和分类用于系统分析和设计
  3. 将结构化分析方法和技术，如SADT方法等用于系统分析与建模
  4. 采用基于问题框架和语义网络的知识表示方法

Peter Coad的面向对象分析方法
  1. 对象是问题领域中真实存在的实体，有定义清晰的边界
  2. 对象中封装有属性和行为
  3. 五个核心概念：对象、属性、服务、结构、主题

结构的建模
  1. 一般-特殊/继承结构，分为自底向上和自顶向下
  2. 整体-部分结构：描述对象间的组合关系

服务的建模
  1. 瞬时服务：对象的创建、结束、修改
  2. 计算服务：对象为其他对象完成计算任务
  3. 监控服务：对象持续监控流程，检查预设条件是否满足


CRC卡片分拣法：是类（class）、责任（Responsibility）和协作（Collaboration）的简称
  1. 识别类，提取出需求中的名词，筛选掉超出问题范围、重复的、代指整个系统的、过于含糊的/具体的
  2. 识别类的功能职责，提取出需求问题中的动词，分析、合并、提炼出正确的职责
  3. 识别类交互协作关系：使用UML类图、用例图

面向对象思维方式的核心理念
  1. 区分接口与实现：接口是从用户角度看待对象，实现则是对象的果核和果肉
  2. 从具体到抽象
  3. 最小接口原则

SOLID原则
- 单一职责原则（SRP）：一个类应该只有一个引起其变化的原因
- 开闭原则（OCP）：软件实体在扩展性方面应该是开放的，而在更改性方面是封闭的
- 里式替换原则（LSP）：子类方法的前置条件不能强于父类方法的前置条件；子类方法的后置条件不能弱于父类方法的后置条件；宽入严出
- 依赖倒置原则（DIP）：依赖关系应该尽量依赖接口，而不是具体类
- 接口分离原则（ISP）：在设计时采用多个和特定客户类有关的接口要比采用一个通用的接口要好

优秀的系统设计的特征：用户友好、易理解、可靠、可扩展、可移植、可伸缩、可重用、简单性

类图建模
  1. 类属性定义：+代表公共属性，-代表私有属性，#代表受保护属性，~代表在package内可见
  2. 类关系：关联关系、聚合和组合关系、泛化关系（继承）、依赖关系、实现关系
  3. 关联关系的种类：自返关联（同类不同对象之间的关系）、二元关联、N元关联
  4. 限定关联：在关连端紧靠源类图标处可以有限定符，限定符是关联的属性，作用为给定关联一端的一个对象和限定符，可确定另一端的一个对象或对象集
  5. 聚合与组合关系：聚合表达一个整体对象与其成员对象之间的关系（棱形箭头）；组合表达一个整体对象与其组成部分之间的关系
  6. 继承关系：意义在于系统环境发生变化时便于添加子类（三角箭头），方式：自顶向下、自底向上
  7. 类图的抽象层次：概念类（主体）、说明类（属性、行为）、实现类（具体数据类型，格式，区间，输入输出）

## 行为建模

顺序图：用来刻画系统实现某个功能的必要步骤
  1. 对象：以某种角色参与交互，语法`<objectname>:<classname>`
  2. 生命线：表示对象存在的时间
  3. 控制焦点：表示对象进行操作的时间片段
  4. 消息：描述对象间的交互操作和值传递过程

绘制顺序图
  1. 在顺序图顶端绘制矩形框，定义参与交互的类实例
  2. 在每个对象下面绘制竖直虚线，表示该对象的生命线
  3. 在对象间添加箭头表示各种类型的消息，跟踪对象间的控制流
  4. 生命线加竖直矩形框定义对象激活期，表示对象正在执行某操作
  5. 根据需要添加框的组合与关联，表示复杂的控制结构

框：包含顺序图的部分控制结构，表示选择或者循环结构，左上角注明结构类型，[]中注明条件

对象的创建和撤销：new进行创建，大写的x表示撤销

顺序图建模风格
  1. 把注意力集中于关键的交互
  2. 对于参数，优先考虑使用参数名而不是参数类型
  3. 不要对明显的返回值建模
  4. 可以把返回值建模为方法调用的一部分

顺序图建模的作用
  1. 帮助分析人员对照检查用例中描述需求，是否已经落实给具体对象去实现
  2. 提醒分析人员去补充遗漏的对象类或操作
  3. 帮助分析人员识别哪些对象是主动对象
  4. 通过将一个特定的对象群体的动态方面建模，深入的理解对象之间的交互


状态图：每一种状态表示一种可能的状态赋值

有限状态机：包含有限数量的状态，模型可以表示动作序列

状态空间：对象每个属性的取值空间的乘积加1

状态图的建模元素
  1. 状态
  2. 事件
  3. 状态转移

状态：一个对象生命期的一个阶段，该阶段中对象要满足一些特定的条件、执行特定的活动或等待某个事件的发生
事件：可以触发对象状态改变的外部刺激，也就是消息的发出与接收
状态迁移：是状态之间的关系，当发生一个事件，条件满足时就会发生从源状态到目标状态的改变

UML图绘制状态机
  1. 状态：一个状态表示在某个时间段内某个陈诉是正确的或者某个动作正在执行或在某个时间等待触发，状态相关的活动类型：do/entry/exit/include；初始状态是实心圆点，结束状态是一个圆圈
  2. 迁移：包括五部分，源状态、触发事件、警戒条件、动作、目标状态，对于给定状态，最终只能产生一种迁移，不同条件之间互斥
  3. 事件：系统需要了解正在发生什么
       - 变更事件：通过布尔表达式中变量的改变触发（when），监控执行，区别于警戒条件只执行一次
       - 调用事件：状态迁移的动作会调用对象的方法，同步事件居多
       - 时间事件：通过时间表达式来确定是否满足事件的触发（after/when）
       - 信号事件：接收一个对象发送的信号，异步事件居多
  4. 动作：状态内部或者状态间迁移时执行的原子操作

UML图中的组合状态（超级状态）：文法上的转换，表达的含义相同，分为OR组合（只能满足一个）和AND组合（并发）

UML图中的历史状态：当激活这个状态时，会保存从组合状态退出时所处的子状态，再次进入组合状态时，可直接进入到这个子状态

状态图的建模风格
  1. 初态放置在左上角，终态放置在右下角
  2. 用过去式命名转移事件
  3. 警戒条件不要重叠
  4. 不要把警戒条件置于初始转移上


## 软件系统设计
处理软件设计的复杂性：随着软件系统规模和复杂性不断增加，对系统的全局结构设计和规划变得比算法的选择和数据结构的设计要重要的多

软件体系结构：包括构成系统的设计元素的描述、设计元素之间的交互、设计元素的组合模式以及在这些模式中的约束 构件+连接件+约束
  1. 构件：具有某种功能的可复用的软件结构单元，表示系统中主要的计算元素和数据存储
  2. 连接：是构件间建立和维护行为关联与信息传递的途径
  3. 连接件：表示构件之间的交互并实现构件之间的连接

体系结构风格：用于描述某一特定应用领域中系统组织的惯用模式，反映了领域中众多系统所共有的结构和语义特性（MVC）
设计模式：描述了软件系统设计过程中常见问题的一些解决方案，通常是从大量的成功实践中总结出来的且被广泛公认的实践和知识
软件框架：软件框架是由开发人员定制的应用系统的骨架，是整个或部分系统的可重用设计，由一组抽象构件和构件实例间的交互方式组成

设计模式的目标是改善代码结构，提高程序的结构质量；框架强调的是设计的重用性和系统的可扩展性，以缩短开发周期，提高开发质量

软件设计原则
  1. 抽象：关注事物中与问题相关部分而忽略其他无关部分的一种思考方法
  2. 封装：是指每个软件单元对其他所有单元都隐藏自己的设计决策，各个单元的特性通过其外部可见的接口来描述
  3. 模块化：是在逻辑上和物理上将整个系统分解成多个更小的部分，其实质是分而治之，即将一个复杂问题分解成若干个简单问题，然后逐个解决

系统分解原则：高内聚，低耦合
  - 内聚性：一个模块或子系统内部的依赖程度
  - 耦合性：两个模块或子系统之间依赖关系的强度

层次化：一个大系统可以逐层分解，每层划分为互相对等的若干模块，模块之间相互独立，互不影响

复用：利用某些已开发、对建立新系统有用的软件元素来生成新的软件系统，好处为提高生产效率，提高软件质量，（源代码复用、软件体系结构复用、框架复用、设计模式复用）

软件体系结构风格
  - 主程序-子程序：从功能的观点设计系统，通过逐步分解和细化，形成整个系统的体系结构
  - 面向对象风格：系统被看成对象的集合，每个对象是数据及其操作方法的封装，系统只通过接口与外界交互，内部实现被封装起来
  - 管道-过滤器风格：把系统任务分成若干连续的处理步骤，这些步骤由通过系统的数据流连接
  - 仓库体系结构：适合于数据由一个模块产生而其他模块使用的场景：剪贴板

三层C/S结构：B/S结构
  - 表示层：包括所有与客户机交互的边界对象，如窗口、表单、网页等
  - 功能层：包括所有的控制和实体对象，实现应用程序的处理逻辑和规则
  - 数据层：实现对数据库的存储、查询和更新

模型-视图-控制器（MVC）结构：将应用程序的数据模型、业务逻辑和用户界面分别放在独立构件中

事件风格：将应用看成是一个构件集合，每个构件直至发生对它有影响的事件时才有所动作
  - 发布订阅模型：订阅者订阅一个或多个频道，发布者向指定的频道发送消息，这时，所有订阅了该频道的订阅者就会收到消息
  - 观察者模式：观察者注入到被观察者中进行事件的监听，随时对被观察者的变化作出反应

软件设计过程：首先是软件交互设计，实现用户和客户端的界面，人机交互方式；接着是系统总体设计，关注系统的质量属性，对整个系统进行模块分解，选择良好的设计策略；最后模块设计与实现，应用良好的设计原则进一步细化和实现模块单元，涉及算法、数据结构、数据库

系统总体设计
  1. 明确系统设计目标
  2. 确定子系统或模块
  3. 选择系统部署方案
  4. 定义设计策略
  5. 评审设计方案

系统设计目标：性能准则、可靠性准则、维护准则、最终用户准则、成本准则

系统模块分解策略
  1. 功能分解
  2. 独立配置数据
  3. 独立出特有的硬件构件
  4. 独立出时间至上的构件
  5. 将人机接口和实现模型分离

数据库
  - 事务：一个操作序列要么被完整执行，要么都不执行，不存在执行部分操作的情况，适用于一些关键操作，比如金融业务中的转账
  - 一致性：1.实时一致性：同时呈现；2.最终一致性：总会在未来某一时刻呈现
  - 关系型数据库：Mysql
  - 非关系型数据库：mongo（key-value，自由模型）
  - 内存数据库：redis


## 软件交互设计
人机交互：人机之间的信息交换过程

GUI设计规则：可视化、一致性、直接映射、有效反馈

格式塔理论
  - 闭合律
  - 连续律
  - 相似律
  - 接近律
  - 对称律
  - 前背律

KLM效率模型：K按下键盘上的一个键（鼠标点击）、P鼠标指点屏幕上的一个位置、H切换输入设备、M每个动作的准备时间、R机器的响应时间
  0. 所有的K前面都要加上M，选择命令的P前面要加上M
  1. 指点后点击的动作PMK中的M要删除
  2. 连续单元操作MK除去第一个，其他的都可以删除，比如输入123，操作为MKMKMK可简化成MKKK
  3. 删除连续终止符前的M，比如一个命令分隔符连着参数可以删除分隔符前的M
  4. 删除命令终止符前的M
  5. 系统响应之前的M应删除

Fitts定律：任务难度和移动时间呈线性关系

  公式：T = a + blog2(D/S + 1)，a和b是和人的控制能力或设备相关的参数，T是移动时间，D是当前位置和目标位置之间的距离，S是目标的大小


## 软件系统测试

软件缺陷的产生
  1. 人的认知问题：认识问题是否全面、关注问题的点是否正确、所采用的的策略是否在解决问题时有额外的负担
  2. 进而引发出需求分析的缺陷、设计系统的缺陷、编码的缺陷

软件测试的目的
  1. 直接目标：发现软件错误，以最少的人力物力发现软件中潜在的各种错误和缺陷并进行修正
  2. 期望目标：检查系统是否满足需求
  3. 附带目标：改进软件开发过程

缺陷的集群性：软件错误具有聚集性，对存在错误的部分重点测试

软件测试类型
  1. 测试对象角度：单元测试、集成测试、系统测试、验收测试
  2. 测试技术角度：黑盒测试（功能测试）、白盒测试（结构测试）
  3. 程序执行角度：静态测试、动态测试
  4. 人工干预角度：手工测试、自动化测试

场景法：通过运用场景对系统的功能点或业务流程进行描述，对应不同的业务场景生成相应的测试用例，从而发现需求和实现中存在的问题

```
举例：ATM取款
普通流：成功取款
备用流：ATM金额不足
备用流：ATM机停电
...
```

Web应用功能测试
  - 网页测试：内容测试、表单测试、链接测试、Cookie测试
  - 网站测试：特定功能测试、数据库测试、设计语言测试

性能指标
  - 并发用户数
  - 响应时间
  - 吞吐量：单位时间内系统处理的客户请求的数量，直接体现软件系统的性能承载能力
  - 资源利用率：系统资源的使用程度，如CPU利用率、内存利用率、磁盘利用率、网络带宽利用率

负载测试：通过逐渐增加系统负载，测试系统性能的变化，最终确定在满足性能指标的情况下，系统能承受的最大负载量，如逐渐增加并发用户数

压力测试：在强负载，测试系统性能的变化，确定系统在什么负载条件处于失效状态

压力测试类型
  - 稳定性压力测试：高负载下持续运行24小时
  - 破坏性压力测试：通过不断增加负载的手段快速造成系统崩溃，让问题尽快暴露出来
  - 渗入测试：通过长时间运行，使问题逐渐渗透出来，从而发现内存泄露、垃圾收集或系统的其他问题，以检验系统的健壮性
  - 峰谷测试：采用高低突变加载方式进行，先加载到高水平负载，然后急剧降低负载，稍微平息一段时间后，再加载到高水平，重复该过程，以发现问题

## 软件交付与维护

项目交付
  1. 实施：将软件系统部署到客服方的计算机系统上，协助客户准备数据基础，使软件系统顺利上线运行
  2. 培训
  3. 验收

实施的三个步骤
  1. 确保软件符合需求，质量过关（全面做好测试工作）
  2. 制定实施计划，包括准备好要发布的代码版本、数据库创建、修改方式、基础数据准备方式
  3. 准备好程序代码和相关文档（用户手册、需求说明书、设计文档）

常见的软件交付过程：单个项目整体开发交付流程是典型的瀑布开发过程
  1. 项目1从主干上拉出分支进行开发
  2. 期间项目2合入主干上线
  3. 项目1开发完毕后，需要将主干代码合入分支进行联调
  4. 多次提测通过后将分支合并到主干并上线

持续集成的交付过程
  1. 所有开发在主干上完成
  2. 持续的提交合并代码到主干
  3. 需要上线的时候，产生分支进行提测
  4. 测试通过后形成上线版本

软件演化的Lehman法则
  1. 持续变化：在用的程序持续的经历变化，逐渐变的不可用
  2. 递增复杂性：程序不断的修改将导致结构恶化，增加了复杂性
  3. 程序演化法则：程序演化服从统计上的确定趋势和恒定性
  4. 组织稳定守恒：编程项目总体活动统计上是不变的
  5. 熟悉程度守恒：后续发行对于整个系统功能不会产生很大改变

软件演化策略
  1. 软件维护：为了修改软件缺陷或者增加功能而对软件进行修改，通常修改局部不改变整个结构
  2. 软件再工程：为了避免软件本身退化而对软件的一部分进行重新设计和构造，提高软件的可维护性和可靠性

逆向工程：以复原软件的规格说明和设计为目标的软件分析过程