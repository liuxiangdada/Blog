# 响应式原理

## 响应式对象

核心是`Object.defineProperty`方法，通过挟持对象属性（给对象属性添加get、set方法），每次取值或者改值得时候都执行额外的操作

Vue在初始化过程中，会把props和data都变成响应式对象，如果子属性也是对象则递归把该对象也变成响应式

## 依赖收集

我们知道响应式对象就是挟持对象属性，接下来我们分析get方法中干了什么，在组件挂载过程中会执行render函数将VNode渲染到真实DOM中，这期间就会从data、props中取值，也就是触发了我们设置的get函数，get函数主要做两件事，一件事是返回该属性所对应的值，这也是其本职工作，另一件事就是记录谁调用了该属性，就是谁使用了我，我以后变了该通知谁，这也就是所谓的依赖收集

get的依赖收集实现的很巧妙，借用了Dep这个中间对象，每个被监听的属性都new了这个类并作为闭包保存在内存中，这个dep对象就负责记录哪些watcher使用了该属性，具体做法是调用闭包dep对象的depend方法，在之前Dep类维护了一个全局静态变量`target`，记录当前渲染/计算的watcher，depend方法会把自身作为参数传入Dep.target的addDep方法，然后在当前渲染watcher的addDep方法中将自身添加到闭包dep的subs属性中

听起来有点绕，为啥不直接把Dep.target加到subs中呢，这是因为我们还需要在watcher实例中处理这个dep，举一个很常见的例子，一个数据在模板中多次使用，这样每次使用都会触发addDep，这时就需要在watcher实例中用newDepIds记录当前已经被订阅过的数据，下次跳过避免重复订阅；另一个例子是如果我们进行条件渲染，模板两个地方使用的数据部分不同，就会存在前一次渲染中用到的数据后一次已经用不到的情况，即这些数据的变化已经对渲染无用了，这时就需要移除这些数据上的订阅：具体做法是在cleanupDeps方法中，每次watcher实例收集完依赖时，就判断上次渲染的数据deps中有哪些是这次渲染的数据newDepIds中不存在的，不存在则移除该订阅，并保存当前渲染数据到deps和depIds，最后清空newDeps和newDepIds，方便下次渲染

## 派发更新

setter函数的一个细节，针对没有设置setter方法的属性，Vue直接把新值赋值给`val = obj[key]`的val，这样也实现了对该属性的修改，实际上我们新建一个变量并赋予对象的某个属性值，其实只是赋值的引用，并不是原始值的拷贝，所以修改该变量会同步引发对象属性的修改

派发更新简单来说就是数据修改触发setter，然后调用dep实例的notify通知订阅watcher实例列表更新，每个wacther都有一个update方法，该方法在正常情况下会将自身推入队列queue中，然后在下一个tick触发更新，具体点是执行watcher实例的run方法，其中会调用get方法，该方法会调用传入的updateComponent方法触发重新渲染，关键代码是下面这一句：
```
vm._update(vm._render(), hydrating)
```

注意，其中的_render函数会在生成VNode节点时引用数据，再一次进行依赖收集，其实首次渲染时也会执行进行初次的依赖收集

派发更新使用队列进行了渲染的优化，首先使用has数组记录wathcer的id确保不会重复添加（其实并不能完全避免，后面会提），然后使用waiting变量避免不会重复触发flushSchedulerQueue，这个设计很巧妙，因为JS是单线程的，所以在执行`nextTick(flushSchedulerQueue)`前，把waiting置为true，确保后面调用queueWatcher方法不会再执行nextTick，这样就能把数据的更新渲染统一推迟到下一个tick执行，提高效率

执行flushSchedulerQueue时，首先对queue进行从小到大排序，这是出于先父后子、先用户watcher后渲染watcher、父watcher在run时会销毁子watcher三点考虑的，接着遍历queue，这里做了一个无限渲染判断，即我们思考这样一种情形，在自定义watcher监听某个数据时，其回调再次修改了该数据，这会导致在执行回调时又一次触发queueWatcher并将该用户watcher插入wathcer从而陷入无限循环，Vue在检查到某个wathcer的id被run了100次以上时会主动跳出遍历并报错

## nextTick

nextTick的实现利用了JS的事件循环，针对浏览器的支持情况不断降级，先尝试Promise，不支持再尝试MutationObserver，接着setImmediate，最后setTimeout，执行的nextTick将回调函数推入callbacks回调队列并在下一tick同步执行

由于Vue内部更新时也使用了nextTick，如果我们调用其外部接口，渲染的回调和用户回调会按照推入callback的先后依次执行，这表明我们最好在修改数据后再调用nextTick获取修改后的数据

## 响应式对象的注意事项

我们在给对象包装成响应式对象时，会检测对象中某个属性的值是否仍为对象，满足则会对该值进行响应式，这意味着我们在初次渲染时就会对所有使用的数据（包括其嵌套数据都收集依赖），这其实已经可以满足一些需求了，但我们注意到，Vue在收集依赖时会判断当前操作响应式对象的某个属性是否为对象，满足则取该对象的ob属性中的dep属性收集依赖，这看起来多此一举，按照常理该嵌套对象已经是响应式对象，其内部的每个属性都可以通过其闭包dep派发更新了，那么这个‘多余的dep属性’是用在哪里呢？

我们知道由于JS的限制（插一句，对于对象，由于是先转化data、prop中的数据，所以后来的属性不具备响应式是正常的，但是对于数组来说，我们操作下标修改数组元素无法获得响应式是不合常理的，由源码可知，Vue并没有对数组的key进行响应式，而是直接对元素进行响应式，Vue的开发者尤大回应是由于性能原因，推测我们一般使用数组来储存列表这种数据量大的数据，相对于对象来说，一个个转化响应式的开销不值得，不如在有需要时调用API触发响应式），Vue无法跟踪新增属性和直接操作数组下标所引发的变化，那么我们就需要实现API来手动触发，Vue是暴露了set函数，内部流程是根据入的参数修改对象，然后把该新值转化为响应式属性，由于我们无法在definReactive函数外部取得闭包dep，当前操作的响应式对象的ob属性中保存的dep属性就有用了，通过它派发更新就能触发重新渲染

## computed和watch

computed和watch其本质都是watcher实例，我们在定义其options或者调用watchAPI时都是实例化watch并在执行回调函数期间取值进行依赖收集，这样数据变更时就能马上执行回调重新计算

对于computed来说，它生成的watcher的lazy属性是为真的，这和普通的wathcer有两点不同，一是在实例化时不会马上求值，而是等到被引用时才求值，求值结果保存在wathcer的value属性中，只有等到其内部依赖变化时才会重新求值，二是派发更新时不会执行run方法，只是重置dirty属性以便重新求值

对于watch来说简单点，它支持传入对象或者函数，对象的话可以指定deep和immediately属性，指定immediately属性时，会在创建时马上执行回调，指定deep时，则会在取值时深度遍历，对嵌套对象进行当前watcher的依赖进行收集；watch在定义时会依据属性名（如果是函数则是函数名）在当前组件实例中寻找求值并进行依赖收集，接着在数据变更时派发更新，统一在下一个tick执行run方法，不同于渲染wathcer，在调用run中的get方法重新求值后，会执行回调