## 什么是单元测试

单元测试，你可以理解为将你的代码切割到最小单元后，对这些单元进行的断言，即这个最小单元能否满足你的期望

原来我所理解的单元测试是针对每一个函数进行的输入测试，后面发现不仅可以是函数，也可以是一个类或者其他你觉得可以当成一个独立的黑盒式的模块，我们不需要去关心其内部实现、逻辑，我们要做的很简单，提供该单元所需要的所有服务，断言其输出是否满足我们的需求

由于单元测试是整个系统（项目）中最底层的环节，不同于其上的服务测试和UI测试，单元测试涉及到的模块关联是最小的，整个系统被划分为成百上千个单元，我们针对这些单元的测试都通过，则可以明确的在软件设计阶段把BUG数降到最小，这极大的减少了整个软件开发的生命周期

编写单元测试的过程实际上是程序员编码过程中的自检，检查自己的逻辑有无问题，对该需求是否理解的足够深刻，对编码的每一个环节是否考虑周全，此外，好的单元测试可以取代原有的手动回归测试，原来的每次改动需要重复进行的测试，可以交给计算机几秒内就检验完成

编写单元测试同时也是对软件设计的一种规范，优秀的代码是可维护和可阅读的，单元测试正是保证这两点的最有效武器，因此，如何编写单元测试，如何让自己的代码更易于编写单元测试是每个程序员在动手之前需要考虑清楚的，一旦你开始思考这些问题，在编码时你就会有意识的运用模块化技巧和函数式编程

好的单元测试和优秀的代码是相辅相成的，正如前面提到的，模块化的代码让你编写单元测试时毫不费力，而好的单元测试让你在后续修改代码时无需执行重复的人工校验，并且能够确认修改是否背离需求

也许很多情况，你觉得代码不需要单元测试，这是令人信服的，因为我们实现一个类似于简单计算器的功能，代码不超过100行，对这些代码的每个环节你在后续都能很快理解和修改，也能很容易的添加新的功能，你觉得这是不需要单元测试的

但是当面对一个大型的后台管理系统时，整个系统功能繁多，十分复杂，函数成百上千，如果不对每个函数进行测试，在系统测试阶段，所耗费的排查时间无法想象，随着后续的迭代和修改，后面的问题排查时间几乎是指数级增长的

## 为什么选择Jest

Jest是Facebook推出的一款单元测试框架，相对于其他测试框架，其最大的特点是开箱即用，内置的断言库、测试覆盖率工具让我们不需要关心其他，只要掌握语法，就能轻松上手

这里我们粗略了解一下前端的测试相关工具

### 断言库

chai，知名的断言库，提供形如Should、Expect、Assert等基本的断言关键字

### 测试框架

karma，测试驱动，非jsdom，基于本地的client/server，提供真实的浏览器环境，用来运行测试用例

mocha，比较老的库，提供基本的测试API，如describe，通常搭配chai使用

jasmine，比mocha早，API基本相同，不同于mocha用于支持NodeJs，它需要karma或者Chutzpah的支持

jest，基于jasmine语法，大而全的测试框架，集成了mocha、chai、jsdom、sinon的功能，用户无需关注其内部实现

### 测试覆盖率工具

istanbul，用于统计测试用例的覆盖情况，主要涉及语句、分支、函数、行数等方面

### mock方法

sinon， 一个简单的mock库，拥有三个主要函数，分别是spies, stub, mock

1. spies主要是虚构一个同名函数，不影响原函数功能

2. stub完全取代原函数调用

3. mock替换模块中的多个方法

了解了测试需要的相关环境后，我们能够看出Jest的优势，功能全面，继承了老的测试框架的功能语法，学习成本低，所以选择Jest作为单元测试的框架


## 如何在Vue项目上进行单元测试

如果你是使用vue-cli构建的项目，可以在可视化界面选择@vue/cli-plugin-unit-jest插件安装即可

如果是命令行调用，则执行
```
vue add @vue/cli-plugin-unit-jest
```

或者直接使用npm安装
```
npm i -D @vue/cli-plugin-unit-jest
```

如果不使用该插件，则需要自己安装Jest用到的相关依赖
```
npm i -D jest vue-jest babel-jest babel-core jest-serializer-vue @babel/preset-env
```

其中，jest是测试框架本身；而vue-jest是用来jest如何处理*.vue文件的预处理器；babel-jest、babel-core和@babel/preset-env是用来处理待测试的JS文件的，因为我们希望使用ES Module语法和stage-x的特性；jest-serializer-vue则是一个用来序列化快照的工具

<font color="red">这里我在配置babel-jest遇到了很多坑，初步看可能是我项目中使用的是老的babel6，但是jest现在支持babel7的语法导致的兼容问题，暂时没有解决，只能使用@vue/cli-plugin-unit-jest，使用这个插件不需要配置babel也不需要安装babel-jest和vue-jest，因为插件内部已经使用了这两个包</font>

相关包都安装完后，我们需要配置jest，可以在package.json文件里，也可以在根目录下创建一个jest.config.js文件（使用jest --init命令），配置如下
```
module.exports = {
  // 如果没有安装@vue/cli-plugin-unit-jest插件无需该行
  preset: "@vue/cli-plugin-unit-jest",
  
  // 告诉jest处理哪些后缀文件
  moduleFileExtensions: ["js", "vue"],
  
  // 告诉jest用什么插件处理这些文件
  transform: {
    "^.+\\.vue$": "<rootDir>/node_modules/vue-jest",
    "^.+\\.js$": "<rootDir>/node_modules/babel-jest"
  },
  transformIgnorePatterns: ["<rootDir>/node_modules/"],

  // 如果使用webpack配置了别名，可以对测试文件的引用使用相同的别名
  moduleNameMapper: {
    "^@/(.*)$": "<rootDir>/src/$1"
  },

  // jest的启动文件
  setupFiles: ["<rootDir>/tests/unit/setup"],

  // 测试文件的匹配范围，默认项目下所有spec.js和test.js文件
  // testMatch: ["<rootDir>/tests/\*\*/\*.spec.js"],

  // 快照序列化
  snapshotSerializers: ["jest-serializer-vue"],

  // 测试忽略文件
  coveragePathIgnorePatterns: [
  ],
  
  // 覆盖率统计文件范围
  collectCoverageFrom: [
    "src/**/*.{js,vue}",
    "!src/main.js",
    "!**/node_modules/**"
  ],
  
  // 测试报告格式
  // coverageReporters: ["html", "text-summary"],
  
  // 是否开启测试覆盖率报告
  // collectCoverage: true
};
```

默认情况下，babel-jest安装后会自动进行配置，但是如果我们的webpack使用了babel-preset-env，这时默认的babel配置会关闭ES Module的转译，为了测试需要，我们需要显式开启，具体操作是在.babelrc文件中添加一个env.test配置项
```
{
  "presets": [["env", { "modules": false }]],
  "env": {
    "test": {
      "presets": [["env", { "targets": { "node": "current" } }]]
    }
  }
}
```
